# 用户数据报协议（UDP）

> 原文：<https://linkedin.github.io/school-of-sre/level101/linux_networking/udp/>

UDP 是传输层协议。DNS 是运行在 UDP 之上的应用层协议(大多数时候)。在进入 UDP 之前，让我们试着理解什么是应用和传输层。DNS 协议由 DNS 客户端(如 dig)和 DNS 服务器(如 named)使用。传输层确保 DNS 请求到达 DNS 服务器进程，同样，响应到达 DNS 客户端进程。多个进程可以在一个系统上运行，它们可以监听任何[端口](https://en.wikipedia.org/wiki/Port_(computer_networking))。DNS 服务器通常监听端口号 53。当客户端发出 DNS 请求时，在填充必要的应用负载后，它通过 **sendto** 系统调用将负载传递给内核。内核随机选取一个端口号( [> 1024](https://www.cyberciti.biz/tips/linux-increase-outgoing-network-sockets-range.html) )作为源端口号，将 53 作为目的端口号，并将数据包发送到更低层。当服务器端的内核收到数据包时，它检查端口号并将数据包排队到 DNS 服务器进程的应用缓冲区，该进程发出 **recvfrom** 系统调用并读取数据包。内核的这一过程称为多路复用(将来自多个应用的数据包组合到相同的较低层)和解复用(将来自单个较低层的数据包分离到多个应用)。多路复用和解复用由传输层完成。

UDP 是最简单的传输层协议之一，它只进行复用和解复用。另一个常见的传输层协议 TCP 做许多其他事情，如可靠的通信、流量控制和拥塞控制。UDP 被设计成轻量级的，以很少的开销处理通信。所以除了多路复用和解复用之外，它不做任何事情。如果运行在 UDP 之上的应用需要 TCP 的任何特性，他们必须在他们的应用中实现它

这个来自 python wiki 的[示例涵盖了一个示例 UDP 客户端和服务器，其中“Hello World”是一个应用有效负载，它被发送到侦听端口号 5005 的服务器。服务器接收数据包并从客户端打印“Hello World”字符串](https://wiki.python.org/moin/UdpCommunication)

## SRE 角色中的应用

1.  如果底层网络速度较慢，UDP 层无法将数据包排入网络层，则来自应用的 sendto syscall 将挂起，直到内核发现其缓冲区被释放。这可能会影响系统的吞吐量。使用 [sysctl 变量](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/5/html/tuning_and_optimizing_red_hat_enterprise_linux_for_oracle_9i_and_10g_databases/sect-oracle_9i_and_10g_tuning_guide-adjusting_network_settings-changing_network_kernel_settings) *net.core.wmem_max* 和 *net.core.wmem_default* 增加写内存缓冲值，为来自慢速网络的应用提供一些缓冲
2.  类似地，如果接收方进程消耗缓冲区的速度很慢，内核必须丢弃由于缓冲区已满而无法排队的数据包。由于 UDP 不保证可靠性，这些丢失的数据包可能会导致数据丢失，除非被应用层跟踪。增加 sysctl 变量 *rmem_default* 和 *rmem_max* 可以为来自快速发送者的缓慢应用提供一些缓冲。