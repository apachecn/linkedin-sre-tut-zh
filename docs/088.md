# 信号

> 原文：<https://linkedin.github.io/school-of-sre/level102/system_calls_and_signals/signals/>

## 中断和信号介绍

中断是一种改变程序正常执行流程的事件，可以由硬件设备甚至 CPU 本身产生。当中断发生时，当前的执行流被挂起，中断处理程序运行。在中断处理程序运行后，先前的执行流被恢复。有三种类型的事件会导致 CPU 中断:硬件中断、软件中断和异常。

信号只不过是软件中断，通知一个进程一个事件已经发生。这些事件可能是来自用户的请求，也可能是发生了系统问题(如内存访问错误)的指示。每个信号都有一个信号编号和一个定义的默认动作。流程可以通过以下任何一种方式对它们做出反应:

*   默认(操作系统提供的)方式
*   捕捉信号并以程序定义的方式处理它们
*   完全忽略信号

## 信号类型

要列出 Linux 系统中可用的信号，可以使用命令`kill -l`。下表列出了信号 1 至 20。要获得完整的信号列表，您可以参考[这里的](https://en.wikipedia.org/wiki/Signal_(IPC))。

| 信号名称 | 信号编号 | 默认操作 | 意义 |
| --- | --- | --- | --- |
| 西格胡普 | one | 结束的 | 在控制终端上检测到挂起或控制进程死亡 |
| 信号情报 | Two | 结束的 | 键盘中断 |
| 西格奎特 | three | 核心转储 | 从键盘退出 |
| -是啊 | four | 核心转储 | 非法指令 |
| 信号陷阱 | five | 核心转储 | 用于调试的跟踪/断点陷阱 |
| 西格奥特·西格伯特 | six | 核心转储 | 异常终止 |
| SIGBUS | seven | 核心转储 | 总线错误 |
| 西格弗 | eight | 核心转储 | 浮点异常 |
| 西格基尔 | nine | 结束的 | 终止信号(无法捕捉或忽略) |
| 西格 1 号 | Ten | 结束的 | 用户定义信号 1 |
| 西格尔瑟夫 | Eleven | 核心转储 | 无效的内存引用 |
| 西格玛瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁瑟鲁 | Twelve | 结束的 | 用户定义信号 2 |
| 信号管 | Thirteen | 结束的 | 管道破裂；写管道没有读者 |
| 信号 | Fourteen | 结束的 | 来自警报的定时器信号 |
| 是 SIGTERM | Fifteen | 结束的 | 过程终止 |
| SIGSTKFLT | Sixteen | 结束的 | 数学协处理器上的堆栈错误 |
| 西格德 | Seventeen | 忽视 | 子进程停止或终止 |
| 西格孔特 | Eighteen | 继续 | 停止后继续 |
| 信号停止 | Nineteen | 停止 | 停止进程(不能被捕获或忽略) |
| SIGTSTP | Twenty | 停止 | 在 tty 处停止输入 |

## 向过程发送信号

有三种不同的方式向进程发送信号:

*   使用 kill 向进程发送信号

Kill 命令可用于向进程发送信号。默认情况下，会发送一个 SIGTERM 信号，但是通过定义信号编号(或信号名称)，可以向进程发送不同类型的信号。例如，命令`kill -9 367`将 SIGKILL 发送给 PID 为 367 的进程

*   通过键盘向过程发送信号

通过按下一些特定的键，可以向正在运行的进程发送信号。例如，按住 Ctrl+C 向杀死它的进程发送 SIGINT。

*   通过另一个进程向进程发送信号

一个进程可以通过 kill()系统调用向另一个进程发送信号。`int kill(pid_t pid, int sig)`系统调用有两个参数，您希望向其发送信号的进程的 pid 和所需信号的信号号。

## 处理信号

参考上一节中的信号表，您可以看到当程序启动时，所有信号都有默认的处理程序。当我们调用 signal 来附加我们自己的处理程序时，我们覆盖了程序响应该信号的默认行为。具体来说，如果我们给 SIGINT 附加一个处理程序，当你按下 <ctrl>+C(或者通过其他任何方式给程序发送一个 SIGINT)时，程序就不再终止；相反，将调用指定为处理程序的函数，该函数将定义程序响应该信号的行为。</ctrl>

让我们举一个处理 SIGINT 信号和终止一个程序的例子。我们将使用 Python 的*信号*库来实现这一点。

当我们按 Ctrl+C 时，SIGINT 信号被发送。从 signals 表中，我们看到 SIGINT 的默认动作是终止进程。为了说明流程如何对默认动作和信号处理程序做出反应，让我们考虑下面的例子。

SIGINT 的默认操作:

让我们首先在 python 环境中运行下面几行代码:

```sh
while 1:
        continue 
```

现在让我们按“Ctrl+C”。

在按下“Ctrl+C”时，SIGINT 中断被发送到进程，根据我们在上一节看到的表，SIGINT 的默认操作是终止进程。我们看到 while 循环被终止，并在控制台上看到以下内容:

```sh
^CTraceback (most recent call last):
  File "<stdin>", line 2, in <module>
  KeyboardInterrupt 
```

当我们按下 Ctrl+C 时，进程收到一个 SIGINT(键盘中断),因此终止(默认操作)。

SIGINT 的信号处理器:

让我们在 Python 环境中运行下面几行代码。

```sh
import signal
import sys

#Start of signal_handler function

def signal_handler(signal, frame):
        print ('You pressed Ctrl+C!')

# End of signal_handler function

signal.signal(signal.SIGINT, signal_handler) 
```

这是一个程序的例子，它为 SIGINT 定义了自己的信号处理程序，覆盖了默认的动作。

现在让我们像以前一样运行 while 和 continue 语句。

```sh
while 1:
        continue 
```

当按下 Ctrl+C 时，我们会看到任何变化吗？程序终止了吗？我们看到下面的输出:

```sh
^CYou pressed Ctrl+C! 
```

每次我们按 Ctrl+C，我们只是看到上面的消息，程序不会终止。为了终止程序，你可以按 Ctrl+Z 来发送 SIGSTOP 信号，它的默认动作是停止进程。

在信号处理程序的例子中，我们定义了一个函数 *signal_handler()* ，它打印“你按了 Ctrl+C！”并且不终止程序。调用这个处理程序有两个参数，信号号和当前堆栈帧(无或一个[帧对象](https://docs.python.org/3/reference/datamodel.html#frame-objects))。 *signal.signal()* 允许定义接收到信号时要执行的自定义处理程序。它的两个参数是您想要捕获的信号编号(名称)和信号处理程序的名称。

## 信号在系统调用中的作用，以 *wait()* 为例

*wait()* 系统调用等待调用进程的一个子进程终止，并在 *statusPtr* 指向的缓冲区中返回该子进程的终止状态。

*   如果父进程调用了 *wait()* 系统调用，那么父进程的执行将被挂起，直到子进程被终止。
*   在子进程终止时，会生成一个 SIGCHLD 信号，由内核传递给父进程。SIGCHLD 信号向父母表明，有一些关于孩子的信息需要收集。
*   收到 SIGCHLD 后，父进程从进程表中获取子进程的状态。即使子进程被终止，进程表中仍有一个条目对应于存储进程条目和 PID 的子进程。
*   当父收集状态时，该条目被删除。因此，子进程的所有痕迹都将从系统中移除。

如果父进程决定不等待子进程的终止，而是执行其后续任务，或者未能读取子进程的退出状态，则即使在子进程终止后，进程表中仍会保留一个条目。子进程的这种状态称为僵尸状态。为了避免持久的僵尸，我们需要有在子进程创建后调用 *wait()* 的代码。通常最好为 SIGCHLD 信号创建一个信号处理程序，在一个循环中调用一个 wait-family 函数，直到没有未收集的子数据。

如果子进程的父进程在子进程之前终止，子进程就会成为孤儿。所有进程的祖先 init/systemd(其进程 ID 为 1)收养了这个孤儿。进一步调用以获取该进程的父 pid 将返回 1。