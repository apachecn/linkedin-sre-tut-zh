# 伸缩

> 原文：<https://linkedin.github.io/school-of-sre/level102/system_design/resiliency/>

一个有弹性的系统是一个在逆境中仍能保持运转的系统。对于我们的应用来说，可能会有许多失败作为不利因素。网络级故障可能会导致整个数据中心瘫痪，机架级或服务器级可能会出现问题，或者云提供商可能会出现问题。我们也可能耗尽容量，或者可能有一个错误的代码推破坏了系统。我们将讨论几个这样的问题，并理解我们如何设计一个系统来解决这些问题。在某些情况下，解决方法可能是不可能的。然而，了解系统稳定性的潜在弱点仍然是有价值的。

弹性架构利用系统设计模式，如适度降级、配额、超时和断路器。让我们在这一节看看其中的一些。

## 定额

一个系统可能有一个组件或一个端点，由多个组件和端点使用。重要的是要有适当的东西来防止一个消费者或客户压倒这样的系统。配额是做到这一点的一种方法——我们简单地为每个组件分配一个特定的配额——通过指定单位时间的请求。违反配额的人要么被警告，要么被除名，这取决于执行情况。这样，我们自己的一个系统行为不当就不会导致对其他系统的拒绝服务。配额还有助于我们防止级联故障。

## 功能退化

当一个具有多个依赖项的系统在其中一个依赖项中遇到故障时，适度地降级到最小的可行功能要比使整个系统陷入停顿好得多。例如，假设我们的应用中有一个端点(服务或特定功能的 URL ),它的职责是从图像的元数据中解析用户上传的图像中的位置信息，并向用户提供位置标记的建议。与其让整个上传失败，还不如跳过这个功能，给用户一个手动标记位置的选项。优雅地降级总比彻底失败好。

## 超时设定

我们有时在应用中调用其他服务或资源，如数据库或 API 端点。当从我们的应用中调用这样的资源时，总是有一个合理的超时是很重要的。甚至不一定是资源对所有请求都失败。特定的请求可能属于高尾部延迟类别。合理的超时有助于保持用户体验的一致性——在某些情况下，失败比令人沮丧的长时间延迟要好。

## 指数后退

当服务端点失败时，重试是查看它是否是暂时失败的一种方式。但是，如果重试也会失败，那么无休止地重试就没有意义了。在足够大的规模下，重试可能会与新请求(很可能会按预期提供服务)竞争，并使系统饱和。为了避免这种情况，我们可以查看重试的指数回退。这实质上降低了客户端重试的速率，当遇到连续的重试失败时。

## 断路器

虽然指数回退是应对重试风暴的一种方式，但断路器可以是另一种方式。断路器可以防止故障渗透到整个系统。否则，流经系统的未减轻的故障可能导致错误警报，恶化平均检测时间(MTTD)和平均解决时间(MTTR)。例如，如果其中一个内存中的缓存节点出现故障，导致请求在缓存初始超时后到达数据库，可能会导致数据库过载。如果没有在缓存节点故障和数据库节点故障之间建立初始联系，则可能会导致实际原因的 MTTD 增加，从而导致 MTTR 增加。

## 自我修复系统

当超过阈值的实例停止响应请求时，具有多个实例的传统负载平衡应用可能会失败——要么是因为它们停机，要么是因为突然有大量请求涌入，导致性能下降。在这种情况下，自我修复系统会添加更多实例来替换失败的实例。当查询中突然出现峰值时，像这样的自动缩放也会有所帮助。如果我们的应用运行在公共云上，这可能只是增加更多的[虚拟机](https://azure.microsoft.com/en-in/overview/what-is-a-virtual-machine/)的问题。如果我们在数据中心外进行内部部署，那么我们将需要更加仔细地考虑容量规划。无论我们如何处理额外容量的增加，简单的增加可能是不够的。我们还应该考虑可能遇到的其他潜在故障模式。例如，负载平衡层本身可能需要扩展，以处理新后端的涌入。

## 持续部署和集成

一个设计良好的系统还需要考虑尽可能模拟生产环境的适当试运行设置。还应该有一种方法让我们在暂存环境中重放生产流量，以彻底测试对生产的更改。