# 查询性能

> 原文：<https://linkedin.github.io/school-of-sre/level101/databases_sql/query_performance/>

### 查询性能调优

查询性能是关系数据库的一个非常重要的方面。如果没有正确调优，select 查询对于应用和 MySQL 服务器来说会变得缓慢而痛苦。重要的任务是识别速度慢的查询，并通过重写它们或在相关表上创建适当的索引来提高它们的性能。

#### 慢速查询日志

慢速查询日志包含执行时间比配置参数 long_query_time 中设置的时间长的 SQL 语句。这些查询是优化的候选对象。有一些很好的工具可以总结慢速查询日志，如 mysqldumpslow(由 MySQL 自己提供)、pt-query-digest(由 Percona 提供)等。以下是用于启用和有效捕获慢速查询的配置参数

| 可变的 | 说明 | 示例值 |
| --- | --- | --- |
| 慢速查询日志 | 启用或禁用慢速查询日志 | 在…上 |
| 慢速查询日志文件 | 慢速查询日志的位置 | /var/lib/mysql/mysql-slow.log |
| 长查询时间 | 阈值时间。耗时超过此时间的查询会记录在慢速查询日志中 | five |
| 日志查询未使用索引 | 当启用慢速查询日志时，不使用任何索引的查询也会记录在慢速查询日志中，即使它们花费的时间比 long_query_time 少。 | 在…上 |

因此，对于这一部分，我们将启用 **slow_query_log** ， **long_query_time** 将保持为 **0.3 (300 ms)** ，并且 **log_queries_not_using** 索引也将启用。

下面是我们将在 employees 数据库上执行的查询。

1.  select * from employees where last _ name = ' Koblick '；
2.  select * from salaries，其中薪金> = 100000；
3.  select * from titles where title = ' Manager '；
4.  select * from employees where year(hire _ date)= 1995；
5.  select year(e.hire_date)，max(s . salary from employees e join salary s on e . EMP _ no = s . EMP _ no group by year(e . hire _ date)；

现在，查询 **1** 、 **3** 和 **4** 在 300 毫秒内执行，但是如果我们检查缓慢的查询日志，我们会发现这些查询被记录下来，因为它们没有使用任何索引。查询 **2** 和 **5** 耗时超过 300 毫秒，并且不使用任何索引。

使用以下命令获取慢速查询日志的摘要

`mysqldumpslow /var/lib/mysql/mysql-slow.log`

![slow query log analysis](img/132a906cf359ee5def0ba65d51739b76.png "slow query log analysis")

除了提到的查询之外，快照中还有其他一些查询。Mysqldumpslow 替换 N(对于数字)和 S(对于字符串)使用的实际值。这可以被`-a`选项覆盖，但是如果在类似的查询中使用不同的值，这将增加输出行。

#### 解释计划

**EXPLAIN** 命令用于我们想要分析的任何查询。它描述了查询执行计划，MySQL 如何查看和执行查询。EXPLAIN 使用 Select、Insert、Update 和 Delete 语句。它讲述了查询的不同方面，例如，如何连接表，是否使用索引等。这里重要的是理解查询的基本解释计划输出，以确定其性能。

让我们以下面的查询为例，

```sh
mysql> explain select * from salaries where salary = 100000;
+----+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-------------+
| id | select_type | table    | partitions | type | possible_keys | key  | key_len | ref  | rows    | filtered | Extra       |
+----+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-------------+
|  1 | SIMPLE      | salaries | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 2838426 |    10.00 | Using where |
+----+-------------+----------+------------+------+---------------+------+---------+------+---------+----------+-------------+
1 row in set, 1 warning (0.00 sec) 
```

以上输出中需要理解的关键方面是:-

*   **分区** -执行查询时考虑的分区数量。只有当表被分区时，它才有效。
*   **Possible_keys** -创建执行计划时考虑的索引列表。
*   **Key** -执行查询时将使用的索引。
*   **Rows** -执行过程中检查的行数。
*   **Filtered** -被检查的行中被过滤掉的行的百分比。最大和最优化的结果在该字段中将有 100。
*   **Extra**——这告诉我们一些关于 MySQL 如何评估的额外信息，查询是否只使用 where 子句来匹配目标行、任何索引或临时表等。

因此，对于上面的查询，我们可以确定没有分区，没有要使用的候选索引，因此根本没有使用索引，检查了超过 2M 的行，只有 10%的行包含在结果中，最后，只有 where 子句用于匹配目标行。

#### 创建索引

索引用于加快为给定的列值选择相关行的速度。如果没有索引，MySQL 从第一行开始，遍历整个表来查找匹配的行。如果表中有太多的行，操作会变得很昂贵。有了索引，MySQL 就可以在不读取整个表的情况下确定开始查找数据的位置。

主键也是最快的索引，与表数据一起存储。辅助索引存储在表数据之外，用于进一步提高 SQL 语句的性能。索引大多存储为 B 树，但也有一些例外，比如空间索引使用 R 树，内存表使用散列索引。

创建索引有两种方法:-

*   当创建一个表时——如果我们预先知道在 select 查询中驱动 where 子句最多的列，那么我们可以在创建一个表时在它们上面放一个索引。
*   修改表——为了提高一个麻烦的查询的性能，我们使用 ALTER 或 CREATE INDEX 命令在一个已经有数据的表上创建一个索引。此操作不会阻塞表，但可能需要一些时间来完成，具体取决于表的大小。

让我们看一下我们在上一节中讨论的查询。很明显，扫描 2M 记录并不是一个好主意，因为只有 10%的记录在结果集中。

因此，我们在 sales 表的 salary 列上创建了一个索引。

`create index idx_salary on salaries(salary)`

运筹学

`alter table salaries add index idx_salary(salary)`

同样的解释计划现在看起来像这样

```sh
mysql> explain select * from salaries where salary = 100000;
+----+-------------+----------+------------+------+---------------+------------+---------+-------+------+----------+-------+
| id | select_type | table    | partitions | type | possible_keys | key        | key_len | ref   | rows | filtered | Extra |
+----+-------------+----------+------------+------+---------------+------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | salaries | NULL       | ref  | idx_salary    | idx_salary | 4       | const |   13 |   100.00 | NULL  |
+----+-------------+----------+------------+------+---------------+------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec) 
```

现在使用的索引是 idx_salary，我们最近创建的那个。该索引实际上只帮助检查了 13 条记录，并且它们都在结果集中。此外，查询执行时间也从 700 毫秒以上减少到几乎可以忽略不计。

让我们看另一个例子。我们在这里搜索名和姓的特定组合。但是，我们也可以只根据姓氏进行搜索。

```sh
mysql> explain select * from employees where last_name = 'Dredge' and first_name = 'Yinghua';
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299468 |     1.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec) 
```

现在，在近 30 万条记录中，只有 1%是结果集。虽然查询时间特别快，因为我们只有 30 万条记录，但如果记录的数量超过数百万，这将是一个痛苦。在这种情况下，我们在 last_name 和 first_name 上创建一个索引，不是单独创建，而是创建一个包含这两个列的复合索引。

`create index idx_last_first on employees(last_name, first_name)`

```sh
mysql> explain select * from employees where last_name = 'Dredge' and first_name = 'Yinghua';
+----+-------------+-----------+------------+------+----------------+----------------+---------+-------------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys  | key            | key_len | ref         | rows | filtered | Extra |
+----+-------------+-----------+------------+------+----------------+----------------+---------+-------------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | ref  | idx_last_first | idx_last_first | 124     | const,const |    1 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+----------------+----------------+---------+-------------+------+----------+-------+
1 row in set, 1 warning (0.00 sec) 
```

我们选择在创建索引时将姓氏放在名字之前，因为优化器在评估查询时从索引最左边的前缀开始。例如，如果我们有一个像 idx(c1，c2，c3)这样的 3 列索引，那么该索引的搜索能力如下- (c1)，(c1，c2)或(c1，c2，c3)，也就是说，如果 where 子句只有 first_name，则该索引不起作用。

```sh
mysql> explain select * from employees where first_name = 'Yinghua';
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 299468 |    10.00 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec) 
```

但是，如果 where 子句中只有 last_name，它将按预期工作。

```sh
mysql> explain select * from employees where last_name = 'Dredge';
+----+-------------+-----------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
| id | select_type | table     | partitions | type | possible_keys  | key            | key_len | ref   | rows | filtered | Extra |
+----+-------------+-----------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
|  1 | SIMPLE      | employees | NULL       | ref  | idx_last_first | idx_last_first | 66      | const |  200 |   100.00 | NULL  |
+----+-------------+-----------+------------+------+----------------+----------------+---------+-------+------+----------+-------+
1 row in set, 1 warning (0.00 sec) 
```

再举一个例子，使用以下查询:-

```sh
create table employees_2 like employees;
create table salaries_2 like salaries;
alter table salaries_2 drop primary key; 
```

为了理解 Select with Join 的示例，我们复制了 employees 和 salary 表，但没有 salary 表的主键。

当您有类似下面的查询时，识别查询的难点就变得很棘手。

```sh
mysql> select e.first_name, e.last_name, s.salary, e.hire_date from employees_2 e join salaries_2 s on e.emp_no=s.emp_no where e.last_name='Dredge';
1860 rows in set (4.44 sec) 
```

这个查询大约需要 4.5 秒来完成，结果集中有 1860 行。让我们看看解释计划。解释计划中将有 2 条记录，因为查询中使用了 2 个表。

```sh
mysql> explain select e.first_name, e.last_name, s.salary, e.hire_date from employees_2 e join salaries_2 s on e.emp_no=s.emp_no where e.last_name='Dredge';
+----+-------------+-------+------------+--------+------------------------+---------+---------+--------------------+---------+----------+-------------+
| id | select_type | table | partitions | type   | possible_keys          | key     | key_len | ref                | rows    | filtered | Extra       |
+----+-------------+-------+------------+--------+------------------------+---------+---------+--------------------+---------+----------+-------------+
|  1 | SIMPLE      | s     | NULL       | ALL    | NULL                   | NULL    | NULL    | NULL               | 2837194 |   100.00 | NULL        |
|  1 | SIMPLE      | e     | NULL       | eq_ref | PRIMARY,idx_last_first | PRIMARY | 4       | employees.s.emp_no |       1 |     5.00 | Using where |
+----+-------------+-------+------------+--------+------------------------+---------+---------+--------------------+---------+----------+-------------+
2 rows in set, 1 warning (0.00 sec) 
```

这些是按评估顺序进行的，即首先评估 salaries _ 2，然后将 employees_2 加入其中。看起来，它扫描了 salaries _ 2 表中几乎所有的行，并尝试按照连接条件匹配 employees_2 行。虽然在获取最终结果集时使用了 where 子句，但是对应于 where 子句的索引没有用于 employees_2 表。

如果连接是在两个具有相同数据类型的索引上完成的，那么它总是更快。因此，让我们在 salaries _ 2 表的 *emp_no* 列上创建一个索引，并再次分析该查询。

`create index idx_empno on salaries_2(emp_no);`

```sh
mysql> explain select e.first_name, e.last_name, s.salary, e.hire_date from employees_2 e join salaries_2 s on e.emp_no=s.emp_no where e.last_name='Dredge';
+----+-------------+-------+------------+------+------------------------+----------------+---------+--------------------+------+----------+-------+
| id | select_type | table | partitions | type | possible_keys          | key            | key_len | ref                | rows | filtered | Extra |
+----+-------------+-------+------------+------+------------------------+----------------+---------+--------------------+------+----------+-------+
|  1 | SIMPLE      | e     | NULL       | ref  | PRIMARY,idx_last_first | idx_last_first | 66      | const              |  200 |   100.00 | NULL  |
|  1 | SIMPLE      | s     | NULL       | ref  | idx_empno              | idx_empno      | 4       | employees.e.emp_no |    9 |   100.00 | NULL  |
+----+-------------+-------+------------+------+------------------------+----------------+---------+--------------------+------+----------+-------+
2 rows in set, 1 warning (0.00 sec) 
```

现在，索引不仅帮助优化器只检查两个表中的几行，还颠倒了评估中表的顺序。首先计算 employees_2 表，并根据 where 子句的索引选择行。然后根据连接条件使用的索引将记录连接到 salaries _ 2 表。查询的执行时间从 4.5 秒下降到 0.02 秒。

```sh
mysql> select e.first_name, e.last_name, s.salary, e.hire_date from employees_2 e join salaries_2 s on e.emp_no=s.emp_no where e.last_name='Dredge'\G
1860 rows in set (0.02 sec) 
```